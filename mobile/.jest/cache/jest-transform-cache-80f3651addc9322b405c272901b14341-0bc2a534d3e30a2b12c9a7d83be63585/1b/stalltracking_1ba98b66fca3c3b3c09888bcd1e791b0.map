{"version":3,"names":["_utils","require","_measurements","MARGIN_OF_ERROR_SECONDS","LOOP_TIMEOUT_INTERVAL_MS","MAX_RUNNING_TRANSACTIONS","StallTrackingInstrumentation","options","arguments","length","undefined","minimumStallThreshold","_classCallCheck2","default","isTracking","_totalStallTime","_stallCount","_lastIntervalMs","_timeout","_statsByTransaction","Map","_minimumStallThreshold","_createClass2","key","value","setupOnce","onTransactionStart","transaction","_this","has","logger","error","_startTracking","set","longestStallTime","atTimestamp","atStart","_getCurrentStats","_flushLeakedTransactions","spanRecorder","originalAdd","add","span","apply","originalSpanFinish","finish","endTimestamp","_markSpanFinish","onTransactionFinish","passedEndTimestamp","transactionStats","get","log","delete","_shouldStopTracking","spans","finishedSpanCount","reduce","count","s","trimEnd","toContext","endWillBeTrimmed","isIdleTransaction","statsOnFinish","spansWillBeCancelled","some","startTimestamp","stats","setMeasurement","STALL_COUNT","stall_count","unit","STALL_TOTAL_TIME","stall_total_time","STALL_LONGEST_TIME","stall_longest_time","spanEndTimestamp","previousStats","Math","abs","timestampInSeconds","timestamp","Object","assign","_b","_a","floor","_iteration","_stopTracking","clearTimeout","_reset","size","clear","now","totalTimeTaken","stallTime","_ref","entries","_ref2","_slicedToArray2","max","setTimeout","bind","counter","len","transactions","keys","t","exports"],"sources":["../../../src/js/tracing/stalltracking.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { IdleTransaction, Span, Transaction } from '@sentry/core';\nimport type { Measurements, MeasurementUnit } from '@sentry/types';\nimport { logger, timestampInSeconds } from '@sentry/utils';\n\nimport { STALL_COUNT, STALL_LONGEST_TIME, STALL_TOTAL_TIME } from '../measurements';\n\nexport interface StallMeasurements extends Measurements {\n  [STALL_COUNT]: { value: number; unit: MeasurementUnit };\n  [STALL_TOTAL_TIME]: { value: number; unit: MeasurementUnit };\n  [STALL_LONGEST_TIME]: { value: number; unit: MeasurementUnit };\n}\n\nexport type StallTrackingOptions = {\n  /**\n   * How long in milliseconds an event loop iteration can be delayed for before being considered a \"stall.\"\n   * @default 100\n   */\n  minimumStallThreshold: number;\n};\n\n/** Margin of error of 20ms */\nconst MARGIN_OF_ERROR_SECONDS = 0.02;\n/** How long between each iteration in the event loop tracker timeout */\nconst LOOP_TIMEOUT_INTERVAL_MS = 50;\n/** Limit for how many transactions the stall tracker will track at a time to prevent leaks due to transactions not being finished */\nconst MAX_RUNNING_TRANSACTIONS = 10;\n\n/**\n * Stall measurement tracker inspired by the `JSEventLoopWatchdog` used internally in React Native:\n * https://github.com/facebook/react-native/blob/006f5afe120c290a37cf6ff896748fbc062bf7ed/Libraries/Interaction/JSEventLoopWatchdog.js\n *\n * However, we modified the interval implementation to instead have a fixed loop timeout interval of `LOOP_TIMEOUT_INTERVAL_MS`.\n * We then would consider that iteration a stall when the total time for that interval to run is greater than `LOOP_TIMEOUT_INTERVAL_MS + minimumStallThreshold`\n */\nexport class StallTrackingInstrumentation {\n  public isTracking: boolean = false;\n\n  private _minimumStallThreshold: number;\n\n  /** Total amount of time of all stalls that occurred during the current tracking session */\n  private _totalStallTime: number = 0;\n  /** Total number of stalls that occurred during the current tracking session */\n  private _stallCount: number = 0;\n\n  /** The last timestamp the iteration ran in milliseconds */\n  private _lastIntervalMs: number = 0;\n  private _timeout: ReturnType<typeof setTimeout> | null = null;\n\n  private _statsByTransaction: Map<\n    Transaction,\n    {\n      longestStallTime: number;\n      atStart: StallMeasurements;\n      atTimestamp: {\n        timestamp: number;\n        stats: StallMeasurements;\n      } | null;\n    }\n  > = new Map();\n\n  public constructor(options: StallTrackingOptions = { minimumStallThreshold: 50 }) {\n    this._minimumStallThreshold = options.minimumStallThreshold;\n  }\n\n  /**\n   * @inheritDoc\n   * Not used for this integration. Instead call `registerTransactionStart` to start tracking.\n   */\n  public setupOnce(): void {\n    // Do nothing.\n  }\n\n  /**\n   * Register a transaction as started. Starts stall tracking if not already running.\n   * @returns A finish method that returns the stall measurements.\n   */\n  public onTransactionStart(transaction: Transaction): void {\n    if (this._statsByTransaction.has(transaction)) {\n      logger.error(\n        '[StallTracking] Tried to start stall tracking on a transaction already being tracked. Measurements might be lost.',\n      );\n\n      return;\n    }\n\n    this._startTracking();\n    this._statsByTransaction.set(transaction, {\n      longestStallTime: 0,\n      atTimestamp: null,\n      atStart: this._getCurrentStats(transaction),\n    });\n    this._flushLeakedTransactions();\n\n    if (transaction.spanRecorder) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const originalAdd = transaction.spanRecorder.add;\n\n      transaction.spanRecorder.add = (span: Span): void => {\n        originalAdd.apply(transaction.spanRecorder, [span]);\n\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        const originalSpanFinish = span.finish;\n\n        span.finish = (endTimestamp?: number) => {\n          // We let the span determine its own end timestamp as well in case anything gets changed upstream\n          originalSpanFinish.apply(span, [endTimestamp]);\n\n          // The span should set a timestamp, so this would be defined.\n          if (span.endTimestamp) {\n            this._markSpanFinish(transaction, span.endTimestamp);\n          }\n        };\n      };\n    }\n  }\n\n  /**\n   * Logs a transaction as finished.\n   * Stops stall tracking if no more transactions are running.\n   * @returns The stall measurements\n   */\n  public onTransactionFinish(transaction: Transaction | IdleTransaction, passedEndTimestamp?: number): void {\n    const transactionStats = this._statsByTransaction.get(transaction);\n\n    if (!transactionStats) {\n      // Transaction has been flushed out somehow, we return null.\n      logger.log('[StallTracking] Stall measurements were not added to transaction due to exceeding the max count.');\n\n      this._statsByTransaction.delete(transaction);\n      this._shouldStopTracking();\n\n      return;\n    }\n\n    const endTimestamp = passedEndTimestamp ?? transaction.endTimestamp;\n\n    const spans = transaction.spanRecorder ? transaction.spanRecorder.spans : [];\n    const finishedSpanCount = spans.reduce((count, s) => (s !== transaction && s.endTimestamp ? count + 1 : count), 0);\n\n    const trimEnd = transaction.toContext().trimEnd;\n    const endWillBeTrimmed = trimEnd && finishedSpanCount > 0;\n\n    /*\n      This is not safe in the case that something changes upstream, but if we're planning to move this over to @sentry/javascript anyways,\n      we can have this temporarily for now.\n    */\n    const isIdleTransaction = 'activities' in transaction;\n\n    let statsOnFinish: StallMeasurements | undefined;\n    if (endTimestamp && isIdleTransaction) {\n      /*\n        There is different behavior regarding child spans in a normal transaction and an idle transaction. In normal transactions,\n        the child spans that aren't finished will be dumped, while in an idle transaction they're cancelled and finished.\n\n        Note: `endTimestamp` will always be defined if this is called on an idle transaction finish. This is because we only instrument\n        idle transactions inside `ReactNativeTracing`, which will pass an `endTimestamp`.\n      */\n\n      // There will be cancelled spans, which means that the end won't be trimmed\n      const spansWillBeCancelled = spans.some(\n        s => s !== transaction && s.startTimestamp < endTimestamp && !s.endTimestamp,\n      );\n\n      if (endWillBeTrimmed && !spansWillBeCancelled) {\n        // the last span's timestamp will be used.\n\n        if (transactionStats.atTimestamp) {\n          statsOnFinish = transactionStats.atTimestamp.stats;\n        }\n      } else {\n        // this endTimestamp will be used.\n        statsOnFinish = this._getCurrentStats(transaction);\n      }\n    } else if (endWillBeTrimmed) {\n      // If `trimEnd` is used, and there is a span to trim to. If there isn't, then the transaction should use `endTimestamp` or generate one.\n      if (transactionStats.atTimestamp) {\n        statsOnFinish = transactionStats.atTimestamp.stats;\n      }\n    } else if (!endTimestamp) {\n      statsOnFinish = this._getCurrentStats(transaction);\n    }\n\n    this._statsByTransaction.delete(transaction);\n    this._shouldStopTracking();\n\n    if (!statsOnFinish) {\n      if (typeof endTimestamp !== 'undefined') {\n        logger.log('[StallTracking] Stall measurements not added due to `endTimestamp` being set.');\n      } else if (trimEnd) {\n        logger.log(\n          '[StallTracking] Stall measurements not added due to `trimEnd` being set but we could not determine the stall measurements at that time.',\n        );\n      }\n\n      return;\n    }\n\n    transaction.setMeasurement(\n      STALL_COUNT,\n      statsOnFinish.stall_count.value - transactionStats.atStart.stall_count.value,\n      transactionStats.atStart.stall_count.unit,\n    );\n\n    transaction.setMeasurement(\n      STALL_TOTAL_TIME,\n      statsOnFinish.stall_total_time.value - transactionStats.atStart.stall_total_time.value,\n      transactionStats.atStart.stall_total_time.unit,\n    );\n\n    transaction.setMeasurement(\n      STALL_LONGEST_TIME,\n      statsOnFinish.stall_longest_time.value,\n      statsOnFinish.stall_longest_time.unit,\n    );\n  }\n\n  /**\n   * Logs the finish time of the span for use in `trimEnd: true` transactions.\n   */\n  private _markSpanFinish(transaction: Transaction, spanEndTimestamp: number): void {\n    const previousStats = this._statsByTransaction.get(transaction);\n    if (previousStats) {\n      if (Math.abs(timestampInSeconds() - spanEndTimestamp) > MARGIN_OF_ERROR_SECONDS) {\n        logger.log(\n          '[StallTracking] Span end not logged due to end timestamp being outside the margin of error from now.',\n        );\n\n        if (previousStats.atTimestamp && previousStats.atTimestamp.timestamp < spanEndTimestamp) {\n          // We also need to delete the stat for the last span, as the transaction would be trimmed to this span not the last one.\n          this._statsByTransaction.set(transaction, {\n            ...previousStats,\n            atTimestamp: null,\n          });\n        }\n      } else {\n        this._statsByTransaction.set(transaction, {\n          ...previousStats,\n          atTimestamp: {\n            timestamp: spanEndTimestamp,\n            stats: this._getCurrentStats(transaction),\n          },\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the current stats for a transaction at a given time.\n   */\n  private _getCurrentStats(transaction: Transaction): StallMeasurements {\n    return {\n      stall_count: { value: this._stallCount, unit: 'none' },\n      stall_total_time: { value: this._totalStallTime, unit: 'millisecond' },\n      stall_longest_time: {\n        value: this._statsByTransaction.get(transaction)?.longestStallTime ?? 0,\n        unit: 'millisecond',\n      },\n    };\n  }\n\n  /**\n   * Start tracking stalls\n   */\n  private _startTracking(): void {\n    if (!this.isTracking) {\n      this.isTracking = true;\n      this._lastIntervalMs = Math.floor(timestampInSeconds() * 1000);\n\n      this._iteration();\n    }\n  }\n\n  /**\n   * Stops the stall tracking interval and calls reset().\n   */\n  private _stopTracking(): void {\n    this.isTracking = false;\n\n    if (this._timeout !== null) {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n\n    this._reset();\n  }\n\n  /**\n   * Will stop tracking if there are no more transactions.\n   */\n  private _shouldStopTracking(): void {\n    if (this._statsByTransaction.size === 0) {\n      this._stopTracking();\n    }\n  }\n\n  /**\n   * Clears all the collected stats\n   */\n  private _reset(): void {\n    this._stallCount = 0;\n    this._totalStallTime = 0;\n    this._lastIntervalMs = 0;\n    this._statsByTransaction.clear();\n  }\n\n  /**\n   * Iteration of the stall tracking interval. Measures how long the timer strayed from its expected time of running, and how\n   * long the stall is for.\n   */\n  private _iteration(): void {\n    const now = timestampInSeconds() * 1000;\n    const totalTimeTaken = now - this._lastIntervalMs;\n\n    if (totalTimeTaken >= LOOP_TIMEOUT_INTERVAL_MS + this._minimumStallThreshold) {\n      const stallTime = totalTimeTaken - LOOP_TIMEOUT_INTERVAL_MS;\n      this._stallCount += 1;\n      this._totalStallTime += stallTime;\n\n      for (const [transaction, value] of this._statsByTransaction.entries()) {\n        const longestStallTime = Math.max(value.longestStallTime ?? 0, stallTime);\n\n        this._statsByTransaction.set(transaction, {\n          ...value,\n          longestStallTime,\n        });\n      }\n    }\n\n    this._lastIntervalMs = now;\n\n    if (this.isTracking) {\n      this._timeout = setTimeout(this._iteration.bind(this), LOOP_TIMEOUT_INTERVAL_MS);\n    }\n  }\n\n  /**\n   * Deletes leaked transactions (Earliest transactions when we have more than MAX_RUNNING_TRANSACTIONS transactions.)\n   */\n  private _flushLeakedTransactions(): void {\n    if (this._statsByTransaction.size > MAX_RUNNING_TRANSACTIONS) {\n      let counter = 0;\n      const len = this._statsByTransaction.size - MAX_RUNNING_TRANSACTIONS;\n      const transactions = this._statsByTransaction.keys();\n      for (const t of transactions) {\n        if (counter >= len) break;\n        counter += 1;\n        this._statsByTransaction.delete(t);\n      }\n    }\n  }\n}\n"],"mappings":"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"}